using Microsoft.VisualBasic;
using Raylib_cs;
using static System.Net.Mime.MediaTypeNames;
using System.Reflection.Emit;
using System.Numerics;
using System;
using System.Text.Json.Nodes;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace raygui_cs
{
    public enum GuiState
    {
        STATE_NORMAL = 0,
        STATE_FOCUSED,
        STATE_PRESSED,
        STATE_DISABLED,
    };
    public enum GuiTextBoxProperty
    {
        TEXT_INNER_PADDING = 16,    // TextBox/TextBoxMulti/ValueBox/Spinner inner text padding
        TEXT_LINES_SPACING,         // TextBoxMulti lines separation
        TEXT_ALIGNMENT_VERTICAL,    // TextBoxMulti vertical alignment: 0-CENTERED, 1-UP, 2-DOWN
        TEXT_MULTILINE,             // TextBox supports multiple lines
        TEXT_WRAP_MODE              // TextBox wrap mode for multiline: 0-NO_WRAP, 1-CHAR_WRAP, 2-WORD_WRAP
    };

    public enum GuiPropertyElement
    {
        BORDER = 0,
        BASE,
        TEXT,
        OTHER
    };
    public enum GuiControlProperty
    {
        BORDER_COLOR_NORMAL = 0,
        BASE_COLOR_NORMAL,
        TEXT_COLOR_NORMAL,
        BORDER_COLOR_FOCUSED,
        BASE_COLOR_FOCUSED,
        TEXT_COLOR_FOCUSED,
        BORDER_COLOR_PRESSED,
        BASE_COLOR_PRESSED,
        TEXT_COLOR_PRESSED,
        BORDER_COLOR_DISABLED,
        BASE_COLOR_DISABLED,
        TEXT_COLOR_DISABLED,
        BORDER_WIDTH,
        TEXT_PADDING,
        TEXT_ALIGNMENT,
        RESERVED
    };
    public enum GuiControl
    {
        // Default -> populates to all controls when set
        DEFAULT = 0,
        // Basic controls
        LABEL,          // Used also for: LABELBUTTON
        BUTTON,
        TOGGLE,         // Used also for: TOGGLEGROUP
        SLIDER,         // Used also for: SLIDERBAR
        PROGRESSBAR,
        CHECKBOX,
        COMBOBOX,
        DROPDOWNBOX,
        TEXTBOX,        // Used also for: TEXTBOXMULTI
        VALUEBOX,
        SPINNER,        // Uses: BUTTON, VALUEBOX
        LISTVIEW,
        COLORPICKER,
        SCROLLBAR,
        STATUSBAR
    };

    public enum GuiTextAlignment
    {
        TEXT_ALIGN_LEFT = 0,
        TEXT_ALIGN_CENTER,
        TEXT_ALIGN_RIGHT,
    };

    public enum GuiDefaultProperty
    {
        TEXT_SIZE = 16,             // Text size (glyphs max height)
        TEXT_SPACING,               // Text spacing between glyphs
        LINE_COLOR,                 // Line control color
        BACKGROUND_COLOR,           // Background color
    };
    public enum GuiToggleProperty
    {
        GROUP_PADDING = 16,         // ToggleGroup separation between toggles
    };

    // Slider/SliderBar
    public enum GuiSliderProperty
    {
        SLIDER_WIDTH = 16,          // Slider size of internal bar
        SLIDER_PADDING              // Slider/SliderBar internal bar padding
    };

    // ProgressBar
    public enum GuiProgressBarProperty
    {
        PROGRESS_PADDING = 16,      // ProgressBar internal padding
    };

    // CheckBox
    public enum GuiCheckBoxProperty
    {
        CHECK_PADDING = 16          // CheckBox internal check padding
    };

    // ComboBox
    public enum GuiComboBoxProperty
    {
        COMBO_BUTTON_WIDTH = 16,    // ComboBox right button width
        COMBO_BUTTON_SPACING        // ComboBox button separation
    };

    // DropdownBox
    public enum GuiDropdownBoxProperty
    {
        ARROW_PADDING = 16,         // DropdownBox arrow separation from border and items
        DROPDOWN_ITEMS_SPACING      // DropdownBox items separation
    };


    // Spinner
    public enum GuiSpinnerProperty
    {
        SPIN_BUTTON_WIDTH = 16,     // Spinner left/right buttons width
        SPIN_BUTTON_SPACING,        // Spinner buttons separation
    };

    // ListView
    public enum GuiListViewProperty
    {
        LIST_ITEMS_HEIGHT = 16,     // ListView items height
        LIST_ITEMS_SPACING,         // ListView items separation
        SCROLLBAR_WIDTH,            // ListView scrollbar size (usually width)
        SCROLLBAR_SIDE,             // ListView scrollbar side (0-left, 1-right)
    };

    // ColorPicker
    public enum GuiColorPickerProperty
    {
        COLOR_SELECTOR_SIZE = 16,
        HUEBAR_WIDTH,               // ColorPicker right hue bar width
        HUEBAR_PADDING,             // ColorPicker right hue bar separation from panel
        HUEBAR_SELECTOR_HEIGHT,     // ColorPicker right hue bar selector height
        HUEBAR_SELECTOR_OVERFLOW    // ColorPicker right hue bar selector overflow
    };

    public enum GuiScrollBarProperty
    {
        ARROWS_SIZE = 16,
        ARROWS_VISIBLE,
        SCROLL_SLIDER_PADDING,      // (SLIDERBAR, SLIDER_PADDING)
        SCROLL_SLIDER_SIZE,
        SCROLL_PADDING,
        SCROLL_SPEED,
    };
    public static class Raygui
    {

        public const int STATE_NORMAL = 0;
        public const int STATE_FOCUSED = 1;
        public const int STATE_PRESSED = 2;
        public const int STATE_DISABLED = 3;

        public const int DEFAULT = 0;// Basic controls
        public const int LABEL = 1;          // Used also for: LABELBUTTON
        public const int BUTTON = 2;
        public const int TOGGLE = 3;         // Used also for: TOGGLEGROUP
        public const int SLIDER = 4;         // Used also for: SLIDERBAR
        public const int PROGRESSBAR = 5;
        public const int CHECKBOX = 6;
        public const int COMBOBOX = 7;
        public const int DROPDOWNBOX = 8;
        public const int TEXTBOX = 9;        // Used also for: TEXTBOXMULTI
        public const int VALUEBOX = 10;
        public const int SPINNER = 11;        // Uses: BUTTON; VALUEBOX
        public const int LISTVIEW = 12;
        public const int COLORPICKER = 13;
        public const int SCROLLBAR = 14;
        public const int STATUSBAR = 15;
        public static bool guiStyleLoaded = false;
        public const int TEXT_INNER_PADDING = 16;    // TextBox/TextBoxMulti/ValueBox/Spinner inner text padding
        public const int TEXT_LINES_SPACING = 17;         // TextBoxMulti lines separation
        public const int TEXT_ALIGNMENT_VERTICAL = 18;    // TextBoxMulti vertical alignment: 0-CENTERED, 1-UP, 2-DOWN
        public const int TEXT_MULTILINE = 19;             // TextBox supports multiple lines
        public const int TEXT_WRAP_MODE = 20;              // TextBox wrap mode for multiline: 0-NO_WRAP, 1-CHAR_WRAP, 2-WORD_WRAP


        public const int BORDER_COLOR_NORMAL = 0;
        public const int BASE_COLOR_NORMAL = 1;
        public const int TEXT_COLOR_NORMAL = 2;
        public const int BORDER_COLOR_FOCUSED = 3;
        public const int BASE_COLOR_FOCUSED = 4;
        public const int TEXT_COLOR_FOCUSED = 5;
        public const int BORDER_COLOR_PRESSED = 6;
        public const int BASE_COLOR_PRESSED = 7;
        public const int TEXT_COLOR_PRESSED = 8;
        public const int BORDER_COLOR_DISABLED = 9;
        public const int BASE_COLOR_DISABLED = 10;
        public const int TEXT_COLOR_DISABLED = 11;
        public const int BORDER_WIDTH = 12;
        public const int TEXT_PADDING = 13;
        public const int TEXT_ALIGNMENT = 14;
        public const int RESERVED = 15;


        public const int TEXT_ALIGN_LEFT = 0;
        public const int TEXT_ALIGN_CENTER = 1;
        public const int TEXT_ALIGN_RIGHT = 2;

        public const int TEXT_SIZE = 16;             // Text size (glyphs max height)
        public const int TEXT_SPACING = 17;               // Text spacing between glyphs
        public const int LINE_COLOR = 18;                 // Line control color
        public const int BACKGROUND_COLOR = 19;           // Background color

        public static GuiState guiState = GuiState.STATE_NORMAL;

        public const int RAYGUI_MAX_CONTROLS = 16;   // Maximum number of standard controls
        public const int RAYGUI_MAX_PROPS_BASE = 16;   // Maximum number of standard properties
        public const int RAYGUI_MAX_PROPS_EXTENDED = 8;   // Maximum number of extended properties


        public const int GROUP_PADDING = 16;         // ToggleGroup separation between toggles


        // Slider/SliderBar
        public const int SLIDER_WIDTH = 16;          // Slider size of internal bar
        public const int SLIDER_PADDING = 17;

        // ProgressBar
        public const int PROGRESS_PADDING = 16;      // ProgressBar internal padding

        // CheckBox
        public const int CHECK_PADDING = 16;        // CheckBox internal check padding


        // ComboBox
        public const int COMBO_BUTTON_WIDTH = 16;    // ComboBox right button width
        public const int COMBO_BUTTON_SPACING = 17;// ComboBox button separation


        // DropdownBox
        public const int ARROW_PADDING = 16;         // DropdownBox arrow separation from border and items
        public const int DROPDOWN_ITEMS_SPACING = 17;// DropdownBox items separation

        // Spinner
        public const int SPIN_BUTTON_WIDTH = 16;     // Spinner left/right buttons width
        public const int SPIN_BUTTON_SPACING = 17;        // Spinner buttons separation


        // ListView
        public const int LIST_ITEMS_HEIGHT = 16;     // ListView items height
        public const int LIST_ITEMS_SPACING = 17;         // ListView items separation
        public const int SCROLLBAR_WIDTH = 18;            // ListView scrollbar size (usually width)
        public const int SCROLLBAR_SIDE = 19;             // ListView scrollbar side (0-left, 1-right)


        // ColorPicker
        public const int COLOR_SELECTOR_SIZE = 16;
        public const int HUEBAR_WIDTH = 17;               // ColorPicker right hue bar width
        public const int HUEBAR_PADDING = 18;             // ColorPicker right hue bar separation from panel
        public const int HUEBAR_SELECTOR_HEIGHT = 19;    // ColorPicker right hue bar selector height
        public const int HUEBAR_SELECTOR_OVERFLOW = 20;    // ColorPicker right hue bar selector overflow


        public const int ARROWS_SIZE = 16;
        public const int ARROWS_VISIBLE = 17;
        public const int SCROLL_SLIDER_PADDING = 18;      // (SLIDERBAR, SLIDER_PADDING)
        public const int SCROLL_SLIDER_SIZE = 19;
        public const int SCROLL_PADDING = 20;
        public const int SCROLL_SPEED = 21;

        public const int SCROLLBAR_LEFT_SIDE = 0;
        public const int SCROLLBAR_RIGHT_SIDE = 1;

        // GuiPropertyElement

        public const int BORDER = 0;
        public const int BASE = 1;
        public const int TEXT = 2;
        public const int OTHER = 3;
        //Defines
        public static int RAYGUI_PANEL_BORDER_WIDTH = 1;
        public static int RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT = 1;
        public const int MAX_LINE_BUFFER_SIZE = 256;
        public const int RAYGUI_MAX_TEXT_LINES = 128;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TEXT_VALIGN_PIXEL_OFFSET(int h) => ((int)h % 2);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int TEXT_VALIGN_PIXEL_OFFSET(float h) => ((int)h % 2);

        public static int ICON_TEXT_PADDING = 4;
        public static bool guiLocked = false;                  // Gui lock state (no inputs processed)
        public static float guiAlpha = 1.0f;                   // Gui element transpacency on drawing
        public static bool guiSliderDragging = false;
        public static uint guiIconScale = 1;
        public static int RAYGUI_ICON_SIZE = 16;          // Size of icons in pixels (squared)
        public static int RAYGUI_ICON_MAX_ICONS = 256;          // Maximum number of icons
        public static int RAYGUI_ICON_MAX_NAME_LENGTH = 32;          // Maximum length of icon name id
        public static uint [ ] guiStyle;
        public static Font guiFont;
        public static int RAYGUI_ICON_DATA_ELEMENTS = (RAYGUI_ICON_SIZE * RAYGUI_ICON_SIZE / 32);
        public static uint [ ] guiIcons;

        public static bool guiTooltip = false;                 // Tooltip enabled/disabled
        public static string? guiTooltipPtr = null;        // Tooltip string pointer (string provided by user)
        static Raygui()
        {
            guiIcons = new uint [ ]{
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_NONE
    0x3ff80000, 0x2f082008, 0x2042207e, 0x40027fc2, 0x40024002, 0x40024002, 0x40024002, 0x00007ffe,      // ICON_FOLDER_FILE_OPEN
    0x3ffe0000, 0x44226422, 0x400247e2, 0x5ffa4002, 0x57ea500a, 0x500a500a, 0x40025ffa, 0x00007ffe,      // ICON_FILE_SAVE_CLASSIC
    0x00000000, 0x0042007e, 0x40027fc2, 0x40024002, 0x41024002, 0x44424282, 0x793e4102, 0x00000100,      // ICON_FOLDER_OPEN
    0x00000000, 0x0042007e, 0x40027fc2, 0x40024002, 0x41024102, 0x44424102, 0x793e4282, 0x00000000,      // ICON_FOLDER_SAVE
    0x3ff00000, 0x201c2010, 0x20042004, 0x21042004, 0x24442284, 0x21042104, 0x20042104, 0x00003ffc,      // ICON_FILE_OPEN
    0x3ff00000, 0x201c2010, 0x20042004, 0x21042004, 0x21042104, 0x22842444, 0x20042104, 0x00003ffc,      // ICON_FILE_SAVE
    0x3ff00000, 0x201c2010, 0x00042004, 0x20041004, 0x20844784, 0x00841384, 0x20042784, 0x00003ffc,      // ICON_FILE_EXPORT
    0x3ff00000, 0x201c2010, 0x20042004, 0x20042004, 0x22042204, 0x22042f84, 0x20042204, 0x00003ffc,      // ICON_FILE_ADD
    0x3ff00000, 0x201c2010, 0x20042004, 0x20042004, 0x25042884, 0x25042204, 0x20042884, 0x00003ffc,      // ICON_FILE_DELETE
    0x3ff00000, 0x201c2010, 0x20042004, 0x20042ff4, 0x20042ff4, 0x20042ff4, 0x20042004, 0x00003ffc,      // ICON_FILETYPE_TEXT
    0x3ff00000, 0x201c2010, 0x27042004, 0x244424c4, 0x26442444, 0x20642664, 0x20042004, 0x00003ffc,      // ICON_FILETYPE_AUDIO
    0x3ff00000, 0x201c2010, 0x26042604, 0x20042004, 0x35442884, 0x2414222c, 0x20042004, 0x00003ffc,      // ICON_FILETYPE_IMAGE
    0x3ff00000, 0x201c2010, 0x20c42004, 0x22442144, 0x22442444, 0x20c42144, 0x20042004, 0x00003ffc,      // ICON_FILETYPE_PLAY
    0x3ff00000, 0x3ffc2ff0, 0x3f3c2ff4, 0x3dbc2eb4, 0x3dbc2bb4, 0x3f3c2eb4, 0x3ffc2ff4, 0x00002ff4,      // ICON_FILETYPE_VIDEO
    0x3ff00000, 0x201c2010, 0x21842184, 0x21842004, 0x21842184, 0x21842184, 0x20042184, 0x00003ffc,      // ICON_FILETYPE_INFO
    0x0ff00000, 0x381c0810, 0x28042804, 0x28042804, 0x28042804, 0x28042804, 0x20102ffc, 0x00003ff0,      // ICON_FILE_COPY
    0x00000000, 0x701c0000, 0x079c1e14, 0x55a000f0, 0x079c00f0, 0x701c1e14, 0x00000000, 0x00000000,      // ICON_FILE_CUT
    0x01c00000, 0x13e41bec, 0x3f841004, 0x204420c4, 0x20442044, 0x20442044, 0x207c2044, 0x00003fc0,      // ICON_FILE_PASTE
    0x00000000, 0x3aa00fe0, 0x2abc2aa0, 0x2aa42aa4, 0x20042aa4, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_CURSOR_HAND
    0x00000000, 0x003c000c, 0x030800c8, 0x30100c10, 0x10202020, 0x04400840, 0x01800280, 0x00000000,      // ICON_CURSOR_POINTER
    0x00000000, 0x00180000, 0x01f00078, 0x03e007f0, 0x07c003e0, 0x04000e40, 0x00000000, 0x00000000,      // ICON_CURSOR_CLASSIC
    0x00000000, 0x04000000, 0x11000a00, 0x04400a80, 0x01100220, 0x00580088, 0x00000038, 0x00000000,      // ICON_PENCIL
    0x04000000, 0x15000a00, 0x50402880, 0x14102820, 0x05040a08, 0x015c028c, 0x007c00bc, 0x00000000,      // ICON_PENCIL_BIG
    0x01c00000, 0x01400140, 0x01400140, 0x0ff80140, 0x0ff80808, 0x0aa80808, 0x0aa80aa8, 0x00000ff8,      // ICON_BRUSH_CLASSIC
    0x1ffc0000, 0x5ffc7ffe, 0x40004000, 0x00807f80, 0x01c001c0, 0x01c001c0, 0x01c001c0, 0x00000080,      // ICON_BRUSH_PAINTER
    0x00000000, 0x00800000, 0x01c00080, 0x03e001c0, 0x07f003e0, 0x036006f0, 0x000001c0, 0x00000000,      // ICON_WATER_DROP
    0x00000000, 0x3e003800, 0x1f803f80, 0x0c201e40, 0x02080c10, 0x00840104, 0x00380044, 0x00000000,      // ICON_COLOR_PICKER
    0x00000000, 0x07800300, 0x1fe00fc0, 0x3f883fd0, 0x0e021f04, 0x02040402, 0x00f00108, 0x00000000,      // ICON_RUBBER
    0x00c00000, 0x02800140, 0x08200440, 0x20081010, 0x2ffe3004, 0x03f807fc, 0x00e001f0, 0x00000040,      // ICON_COLOR_BUCKET
    0x00000000, 0x21843ffc, 0x01800180, 0x01800180, 0x01800180, 0x01800180, 0x03c00180, 0x00000000,      // ICON_TEXT_T
    0x00800000, 0x01400180, 0x06200340, 0x0c100620, 0x1ff80c10, 0x380c1808, 0x70067004, 0x0000f80f,      // ICON_TEXT_A
    0x78000000, 0x50004000, 0x00004800, 0x03c003c0, 0x03c003c0, 0x00100000, 0x0002000a, 0x0000000e,      // ICON_SCALE
    0x75560000, 0x5e004002, 0x54001002, 0x41001202, 0x408200fe, 0x40820082, 0x40820082, 0x00006afe,      // ICON_RESIZE
    0x00000000, 0x3f003f00, 0x3f003f00, 0x3f003f00, 0x00400080, 0x001c0020, 0x001c001c, 0x00000000,      // ICON_FILTER_POINT
    0x6d800000, 0x00004080, 0x40804080, 0x40800000, 0x00406d80, 0x001c0020, 0x001c001c, 0x00000000,      // ICON_FILTER_BILINEAR
    0x40080000, 0x1ffe2008, 0x14081008, 0x11081208, 0x10481088, 0x10081028, 0x10047ff8, 0x00001002,      // ICON_CROP
    0x00100000, 0x3ffc0010, 0x2ab03550, 0x22b02550, 0x20b02150, 0x20302050, 0x2000fff0, 0x00002000,      // ICON_CROP_ALPHA
    0x40000000, 0x1ff82000, 0x04082808, 0x01082208, 0x00482088, 0x00182028, 0x35542008, 0x00000002,      // ICON_SQUARE_TOGGLE
    0x00000000, 0x02800280, 0x06c006c0, 0x0ea00ee0, 0x1e901eb0, 0x3e883e98, 0x7efc7e8c, 0x00000000,      // ICON_SYMMETRY
    0x01000000, 0x05600100, 0x1d480d50, 0x7d423d44, 0x3d447d42, 0x0d501d48, 0x01000560, 0x00000100,      // ICON_SYMMETRY_HORIZONTAL
    0x01800000, 0x04200240, 0x10080810, 0x00001ff8, 0x00007ffe, 0x0ff01ff8, 0x03c007e0, 0x00000180,      // ICON_SYMMETRY_VERTICAL
    0x00000000, 0x010800f0, 0x02040204, 0x02040204, 0x07f00308, 0x1c000e00, 0x30003800, 0x00000000,      // ICON_LENS
    0x00000000, 0x061803f0, 0x08240c0c, 0x08040814, 0x0c0c0804, 0x23f01618, 0x18002400, 0x00000000,      // ICON_LENS_BIG
    0x00000000, 0x00000000, 0x1c7007c0, 0x638e3398, 0x1c703398, 0x000007c0, 0x00000000, 0x00000000,      // ICON_EYE_ON
    0x00000000, 0x10002000, 0x04700fc0, 0x610e3218, 0x1c703098, 0x001007a0, 0x00000008, 0x00000000,      // ICON_EYE_OFF
    0x00000000, 0x00007ffc, 0x40047ffc, 0x10102008, 0x04400820, 0x02800280, 0x02800280, 0x00000100,      // ICON_FILTER_TOP
    0x00000000, 0x40027ffe, 0x10082004, 0x04200810, 0x02400240, 0x02400240, 0x01400240, 0x000000c0,      // ICON_FILTER
    0x00800000, 0x00800080, 0x00000080, 0x3c9e0000, 0x00000000, 0x00800080, 0x00800080, 0x00000000,      // ICON_TARGET_POINT
    0x00800000, 0x00800080, 0x00800080, 0x3f7e01c0, 0x008001c0, 0x00800080, 0x00800080, 0x00000000,      // ICON_TARGET_SMALL
    0x00800000, 0x00800080, 0x03e00080, 0x3e3e0220, 0x03e00220, 0x00800080, 0x00800080, 0x00000000,      // ICON_TARGET_BIG
    0x01000000, 0x04400280, 0x01000100, 0x43842008, 0x43849ab2, 0x01002008, 0x04400100, 0x01000280,      // ICON_TARGET_MOVE
    0x01000000, 0x04400280, 0x01000100, 0x41042108, 0x41049ff2, 0x01002108, 0x04400100, 0x01000280,      // ICON_CURSOR_MOVE
    0x781e0000, 0x500a4002, 0x04204812, 0x00000240, 0x02400000, 0x48120420, 0x4002500a, 0x0000781e,      // ICON_CURSOR_SCALE
    0x00000000, 0x20003c00, 0x24002800, 0x01000200, 0x00400080, 0x00140024, 0x003c0004, 0x00000000,      // ICON_CURSOR_SCALE_RIGHT
    0x00000000, 0x0004003c, 0x00240014, 0x00800040, 0x02000100, 0x28002400, 0x3c002000, 0x00000000,      // ICON_CURSOR_SCALE_LEFT
    0x00000000, 0x00100020, 0x10101fc8, 0x10001020, 0x10001000, 0x10001000, 0x00001fc0, 0x00000000,      // ICON_UNDO
    0x00000000, 0x08000400, 0x080813f8, 0x00080408, 0x00080008, 0x00080008, 0x000003f8, 0x00000000,      // ICON_REDO
    0x00000000, 0x3ffc0000, 0x20042004, 0x20002000, 0x20402000, 0x3f902020, 0x00400020, 0x00000000,      // ICON_REREDO
    0x00000000, 0x3ffc0000, 0x20042004, 0x27fc2004, 0x20202000, 0x3fc82010, 0x00200010, 0x00000000,      // ICON_MUTATE
    0x00000000, 0x0ff00000, 0x10081818, 0x11801008, 0x10001180, 0x18101020, 0x00100fc8, 0x00000020,      // ICON_ROTATE
    0x00000000, 0x04000200, 0x240429fc, 0x20042204, 0x20442004, 0x3f942024, 0x00400020, 0x00000000,      // ICON_REPEAT
    0x00000000, 0x20001000, 0x22104c0e, 0x00801120, 0x11200040, 0x4c0e2210, 0x10002000, 0x00000000,      // ICON_SHUFFLE
    0x7ffe0000, 0x50024002, 0x44024802, 0x41024202, 0x40424082, 0x40124022, 0x4002400a, 0x00007ffe,      // ICON_EMPTYBOX
    0x00800000, 0x03e00080, 0x08080490, 0x3c9e0808, 0x08080808, 0x03e00490, 0x00800080, 0x00000000,      // ICON_TARGET
    0x00800000, 0x00800080, 0x00800080, 0x3ffe01c0, 0x008001c0, 0x00800080, 0x00800080, 0x00000000,      // ICON_TARGET_SMALL_FILL
    0x00800000, 0x00800080, 0x03e00080, 0x3ffe03e0, 0x03e003e0, 0x00800080, 0x00800080, 0x00000000,      // ICON_TARGET_BIG_FILL
    0x01000000, 0x07c00380, 0x01000100, 0x638c2008, 0x638cfbbe, 0x01002008, 0x07c00100, 0x01000380,      // ICON_TARGET_MOVE_FILL
    0x01000000, 0x07c00380, 0x01000100, 0x610c2108, 0x610cfffe, 0x01002108, 0x07c00100, 0x01000380,      // ICON_CURSOR_MOVE_FILL
    0x781e0000, 0x6006700e, 0x04204812, 0x00000240, 0x02400000, 0x48120420, 0x700e6006, 0x0000781e,      // ICON_CURSOR_SCALE_FILL
    0x00000000, 0x38003c00, 0x24003000, 0x01000200, 0x00400080, 0x000c0024, 0x003c001c, 0x00000000,      // ICON_CURSOR_SCALE_RIGHT_FILL
    0x00000000, 0x001c003c, 0x0024000c, 0x00800040, 0x02000100, 0x30002400, 0x3c003800, 0x00000000,      // ICON_CURSOR_SCALE_LEFT_FILL
    0x00000000, 0x00300020, 0x10301ff8, 0x10001020, 0x10001000, 0x10001000, 0x00001fc0, 0x00000000,      // ICON_UNDO_FILL
    0x00000000, 0x0c000400, 0x0c081ff8, 0x00080408, 0x00080008, 0x00080008, 0x000003f8, 0x00000000,      // ICON_REDO_FILL
    0x00000000, 0x3ffc0000, 0x20042004, 0x20002000, 0x20402000, 0x3ff02060, 0x00400060, 0x00000000,      // ICON_REREDO_FILL
    0x00000000, 0x3ffc0000, 0x20042004, 0x27fc2004, 0x20202000, 0x3ff82030, 0x00200030, 0x00000000,      // ICON_MUTATE_FILL
    0x00000000, 0x0ff00000, 0x10081818, 0x11801008, 0x10001180, 0x18301020, 0x00300ff8, 0x00000020,      // ICON_ROTATE_FILL
    0x00000000, 0x06000200, 0x26042ffc, 0x20042204, 0x20442004, 0x3ff42064, 0x00400060, 0x00000000,      // ICON_REPEAT_FILL
    0x00000000, 0x30001000, 0x32107c0e, 0x00801120, 0x11200040, 0x7c0e3210, 0x10003000, 0x00000000,      // ICON_SHUFFLE_FILL
    0x00000000, 0x30043ffc, 0x24042804, 0x21042204, 0x20442084, 0x20142024, 0x3ffc200c, 0x00000000,      // ICON_EMPTYBOX_SMALL
    0x00000000, 0x20043ffc, 0x20042004, 0x20042004, 0x20042004, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX
    0x00000000, 0x23c43ffc, 0x23c423c4, 0x200423c4, 0x20042004, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_TOP
    0x00000000, 0x3e043ffc, 0x3e043e04, 0x20043e04, 0x20042004, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_TOP_RIGHT
    0x00000000, 0x20043ffc, 0x20042004, 0x3e043e04, 0x3e043e04, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_RIGHT
    0x00000000, 0x20043ffc, 0x20042004, 0x20042004, 0x3e042004, 0x3e043e04, 0x3ffc3e04, 0x00000000,      // ICON_BOX_BOTTOM_RIGHT
    0x00000000, 0x20043ffc, 0x20042004, 0x20042004, 0x23c42004, 0x23c423c4, 0x3ffc23c4, 0x00000000,      // ICON_BOX_BOTTOM
    0x00000000, 0x20043ffc, 0x20042004, 0x20042004, 0x207c2004, 0x207c207c, 0x3ffc207c, 0x00000000,      // ICON_BOX_BOTTOM_LEFT
    0x00000000, 0x20043ffc, 0x20042004, 0x207c207c, 0x207c207c, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_LEFT
    0x00000000, 0x207c3ffc, 0x207c207c, 0x2004207c, 0x20042004, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_TOP_LEFT
    0x00000000, 0x20043ffc, 0x20042004, 0x23c423c4, 0x23c423c4, 0x20042004, 0x3ffc2004, 0x00000000,      // ICON_BOX_CENTER
    0x7ffe0000, 0x40024002, 0x47e24182, 0x4ff247e2, 0x47e24ff2, 0x418247e2, 0x40024002, 0x00007ffe,      // ICON_BOX_CIRCLE_MASK
    0x7fff0000, 0x40014001, 0x40014001, 0x49555ddd, 0x4945495d, 0x400149c5, 0x40014001, 0x00007fff,      // ICON_POT
    0x7ffe0000, 0x53327332, 0x44ce4cce, 0x41324332, 0x404e40ce, 0x48125432, 0x4006540e, 0x00007ffe,      // ICON_ALPHA_MULTIPLY
    0x7ffe0000, 0x53327332, 0x44ce4cce, 0x41324332, 0x5c4e40ce, 0x44124432, 0x40065c0e, 0x00007ffe,      // ICON_ALPHA_CLEAR
    0x7ffe0000, 0x42fe417e, 0x42fe417e, 0x42fe417e, 0x42fe417e, 0x42fe417e, 0x42fe417e, 0x00007ffe,      // ICON_DITHERING
    0x07fe0000, 0x1ffa0002, 0x7fea000a, 0x402a402a, 0x5b2a512a, 0x5128552a, 0x40205128, 0x00007fe0,      // ICON_MIPMAPS
    0x00000000, 0x1ff80000, 0x12481248, 0x12481ff8, 0x1ff81248, 0x12481248, 0x00001ff8, 0x00000000,      // ICON_BOX_GRID
    0x12480000, 0x7ffe1248, 0x12481248, 0x12487ffe, 0x7ffe1248, 0x12481248, 0x12487ffe, 0x00001248,      // ICON_GRID
    0x00000000, 0x1c380000, 0x1c3817e8, 0x08100810, 0x08100810, 0x17e81c38, 0x00001c38, 0x00000000,      // ICON_BOX_CORNERS_SMALL
    0x700e0000, 0x700e5ffa, 0x20042004, 0x20042004, 0x20042004, 0x20042004, 0x5ffa700e, 0x0000700e,      // ICON_BOX_CORNERS_BIG
    0x3f7e0000, 0x21422142, 0x21422142, 0x00003f7e, 0x21423f7e, 0x21422142, 0x3f7e2142, 0x00000000,      // ICON_FOUR_BOXES
    0x00000000, 0x3bb80000, 0x3bb83bb8, 0x3bb80000, 0x3bb83bb8, 0x3bb80000, 0x3bb83bb8, 0x00000000,      // ICON_GRID_FILL
    0x7ffe0000, 0x7ffe7ffe, 0x77fe7000, 0x77fe77fe, 0x777e7700, 0x777e777e, 0x777e777e, 0x0000777e,      // ICON_BOX_MULTISIZE
    0x781e0000, 0x40024002, 0x00004002, 0x01800000, 0x00000180, 0x40020000, 0x40024002, 0x0000781e,      // ICON_ZOOM_SMALL
    0x781e0000, 0x40024002, 0x00004002, 0x03c003c0, 0x03c003c0, 0x40020000, 0x40024002, 0x0000781e,      // ICON_ZOOM_MEDIUM
    0x781e0000, 0x40024002, 0x07e04002, 0x07e007e0, 0x07e007e0, 0x400207e0, 0x40024002, 0x0000781e,      // ICON_ZOOM_BIG
    0x781e0000, 0x5ffa4002, 0x1ff85ffa, 0x1ff81ff8, 0x1ff81ff8, 0x5ffa1ff8, 0x40025ffa, 0x0000781e,      // ICON_ZOOM_ALL
    0x00000000, 0x2004381c, 0x00002004, 0x00000000, 0x00000000, 0x20040000, 0x381c2004, 0x00000000,      // ICON_ZOOM_CENTER
    0x00000000, 0x1db80000, 0x10081008, 0x10080000, 0x00001008, 0x10081008, 0x00001db8, 0x00000000,      // ICON_BOX_DOTS_SMALL
    0x35560000, 0x00002002, 0x00002002, 0x00002002, 0x00002002, 0x00002002, 0x35562002, 0x00000000,      // ICON_BOX_DOTS_BIG
    0x7ffe0000, 0x40024002, 0x48124ff2, 0x49924812, 0x48124992, 0x4ff24812, 0x40024002, 0x00007ffe,      // ICON_BOX_CONCENTRIC
    0x00000000, 0x10841ffc, 0x10841084, 0x1ffc1084, 0x10841084, 0x10841084, 0x00001ffc, 0x00000000,      // ICON_BOX_GRID_BIG
    0x00000000, 0x00000000, 0x10000000, 0x04000800, 0x01040200, 0x00500088, 0x00000020, 0x00000000,      // ICON_OK_TICK
    0x00000000, 0x10080000, 0x04200810, 0x01800240, 0x02400180, 0x08100420, 0x00001008, 0x00000000,      // ICON_CROSS
    0x00000000, 0x02000000, 0x00800100, 0x00200040, 0x00200010, 0x00800040, 0x02000100, 0x00000000,      // ICON_ARROW_LEFT
    0x00000000, 0x00400000, 0x01000080, 0x04000200, 0x04000800, 0x01000200, 0x00400080, 0x00000000,      // ICON_ARROW_RIGHT
    0x00000000, 0x00000000, 0x00000000, 0x08081004, 0x02200410, 0x00800140, 0x00000000, 0x00000000,      // ICON_ARROW_DOWN
    0x00000000, 0x00000000, 0x01400080, 0x04100220, 0x10040808, 0x00000000, 0x00000000, 0x00000000,      // ICON_ARROW_UP
    0x00000000, 0x02000000, 0x03800300, 0x03e003c0, 0x03e003f0, 0x038003c0, 0x02000300, 0x00000000,      // ICON_ARROW_LEFT_FILL
    0x00000000, 0x00400000, 0x01c000c0, 0x07c003c0, 0x07c00fc0, 0x01c003c0, 0x004000c0, 0x00000000,      // ICON_ARROW_RIGHT_FILL
    0x00000000, 0x00000000, 0x00000000, 0x0ff81ffc, 0x03e007f0, 0x008001c0, 0x00000000, 0x00000000,      // ICON_ARROW_DOWN_FILL
    0x00000000, 0x00000000, 0x01c00080, 0x07f003e0, 0x1ffc0ff8, 0x00000000, 0x00000000, 0x00000000,      // ICON_ARROW_UP_FILL
    0x00000000, 0x18a008c0, 0x32881290, 0x24822686, 0x26862482, 0x12903288, 0x08c018a0, 0x00000000,      // ICON_AUDIO
    0x00000000, 0x04800780, 0x004000c0, 0x662000f0, 0x08103c30, 0x130a0e18, 0x0000318e, 0x00000000,      // ICON_FX
    0x00000000, 0x00800000, 0x08880888, 0x2aaa0a8a, 0x0a8a2aaa, 0x08880888, 0x00000080, 0x00000000,      // ICON_WAVE
    0x00000000, 0x00600000, 0x01080090, 0x02040108, 0x42044204, 0x24022402, 0x00001800, 0x00000000,      // ICON_WAVE_SINUS
    0x00000000, 0x07f80000, 0x04080408, 0x04080408, 0x04080408, 0x7c0e0408, 0x00000000, 0x00000000,      // ICON_WAVE_SQUARE
    0x00000000, 0x00000000, 0x00a00040, 0x22084110, 0x08021404, 0x00000000, 0x00000000, 0x00000000,      // ICON_WAVE_TRIANGULAR
    0x00000000, 0x00000000, 0x04200000, 0x01800240, 0x02400180, 0x00000420, 0x00000000, 0x00000000,      // ICON_CROSS_SMALL
    0x00000000, 0x18380000, 0x12281428, 0x10a81128, 0x112810a8, 0x14281228, 0x00001838, 0x00000000,      // ICON_PLAYER_PREVIOUS
    0x00000000, 0x18000000, 0x11801600, 0x10181060, 0x10601018, 0x16001180, 0x00001800, 0x00000000,      // ICON_PLAYER_PLAY_BACK
    0x00000000, 0x00180000, 0x01880068, 0x18080608, 0x06081808, 0x00680188, 0x00000018, 0x00000000,      // ICON_PLAYER_PLAY
    0x00000000, 0x1e780000, 0x12481248, 0x12481248, 0x12481248, 0x12481248, 0x00001e78, 0x00000000,      // ICON_PLAYER_PAUSE
    0x00000000, 0x1ff80000, 0x10081008, 0x10081008, 0x10081008, 0x10081008, 0x00001ff8, 0x00000000,      // ICON_PLAYER_STOP
    0x00000000, 0x1c180000, 0x14481428, 0x15081488, 0x14881508, 0x14281448, 0x00001c18, 0x00000000,      // ICON_PLAYER_NEXT
    0x00000000, 0x03c00000, 0x08100420, 0x10081008, 0x10081008, 0x04200810, 0x000003c0, 0x00000000,      // ICON_PLAYER_RECORD
    0x00000000, 0x0c3007e0, 0x13c81818, 0x14281668, 0x14281428, 0x1c381c38, 0x08102244, 0x00000000,      // ICON_MAGNET
    0x07c00000, 0x08200820, 0x3ff80820, 0x23882008, 0x21082388, 0x20082108, 0x1ff02008, 0x00000000,      // ICON_LOCK_CLOSE
    0x07c00000, 0x08000800, 0x3ff80800, 0x23882008, 0x21082388, 0x20082108, 0x1ff02008, 0x00000000,      // ICON_LOCK_OPEN
    0x01c00000, 0x0c180770, 0x3086188c, 0x60832082, 0x60034781, 0x30062002, 0x0c18180c, 0x01c00770,      // ICON_CLOCK
    0x0a200000, 0x1b201b20, 0x04200e20, 0x04200420, 0x04700420, 0x0e700e70, 0x0e700e70, 0x04200e70,      // ICON_TOOLS
    0x01800000, 0x3bdc318c, 0x0ff01ff8, 0x7c3e1e78, 0x1e787c3e, 0x1ff80ff0, 0x318c3bdc, 0x00000180,      // ICON_GEAR
    0x01800000, 0x3ffc318c, 0x1c381ff8, 0x781e1818, 0x1818781e, 0x1ff81c38, 0x318c3ffc, 0x00000180,      // ICON_GEAR_BIG
    0x00000000, 0x08080ff8, 0x08081ffc, 0x0aa80aa8, 0x0aa80aa8, 0x0aa80aa8, 0x08080aa8, 0x00000ff8,      // ICON_BIN
    0x00000000, 0x00000000, 0x20043ffc, 0x08043f84, 0x04040f84, 0x04040784, 0x000007fc, 0x00000000,      // ICON_HAND_POINTER
    0x00000000, 0x24400400, 0x00001480, 0x6efe0e00, 0x00000e00, 0x24401480, 0x00000400, 0x00000000,      // ICON_LASER
    0x00000000, 0x03c00000, 0x08300460, 0x11181118, 0x11181118, 0x04600830, 0x000003c0, 0x00000000,      // ICON_COIN
    0x00000000, 0x10880080, 0x06c00810, 0x366c07e0, 0x07e00240, 0x00001768, 0x04200240, 0x00000000,      // ICON_EXPLOSION
    0x00000000, 0x3d280000, 0x2528252c, 0x3d282528, 0x05280528, 0x05e80528, 0x00000000, 0x00000000,      // ICON_1UP
    0x01800000, 0x03c003c0, 0x018003c0, 0x0ff007e0, 0x0bd00bd0, 0x0a500bd0, 0x02400240, 0x02400240,      // ICON_PLAYER
    0x01800000, 0x03c003c0, 0x118013c0, 0x03c81ff8, 0x07c003c8, 0x04400440, 0x0c080478, 0x00000000,      // ICON_PLAYER_JUMP
    0x3ff80000, 0x30183ff8, 0x30183018, 0x3ff83ff8, 0x03000300, 0x03c003c0, 0x03e00300, 0x000003e0,      // ICON_KEY
    0x3ff80000, 0x3ff83ff8, 0x33983ff8, 0x3ff83398, 0x3ff83ff8, 0x00000540, 0x0fe00aa0, 0x00000fe0,      // ICON_DEMON
    0x00000000, 0x0ff00000, 0x20041008, 0x25442004, 0x10082004, 0x06000bf0, 0x00000300, 0x00000000,      // ICON_TEXT_POPUP
    0x00000000, 0x11440000, 0x07f00be8, 0x1c1c0e38, 0x1c1c0c18, 0x07f00e38, 0x11440be8, 0x00000000,      // ICON_GEAR_EX
    0x00000000, 0x20080000, 0x0c601010, 0x07c00fe0, 0x07c007c0, 0x0c600fe0, 0x20081010, 0x00000000,      // ICON_CRACK
    0x00000000, 0x20080000, 0x0c601010, 0x04400fe0, 0x04405554, 0x0c600fe0, 0x20081010, 0x00000000,      // ICON_CRACK_POINTS
    0x00000000, 0x00800080, 0x01c001c0, 0x1ffc3ffe, 0x03e007f0, 0x07f003e0, 0x0c180770, 0x00000808,      // ICON_STAR
    0x0ff00000, 0x08180810, 0x08100818, 0x0a100810, 0x08180810, 0x08100818, 0x08100810, 0x00001ff8,      // ICON_DOOR
    0x0ff00000, 0x08100810, 0x08100810, 0x10100010, 0x4f902010, 0x10102010, 0x08100010, 0x00000ff0,      // ICON_EXIT
    0x00040000, 0x001f000e, 0x0ef40004, 0x12f41284, 0x0ef41214, 0x10040004, 0x7ffc3004, 0x10003000,      // ICON_MODE_2D
    0x78040000, 0x501f600e, 0x0ef44004, 0x12f41284, 0x0ef41284, 0x10140004, 0x7ffc300c, 0x10003000,      // ICON_MODE_3D
    0x7fe00000, 0x50286030, 0x47fe4804, 0x44224402, 0x44224422, 0x241275e2, 0x0c06140a, 0x000007fe,      // ICON_CUBE
    0x7fe00000, 0x5ff87ff0, 0x47fe4ffc, 0x44224402, 0x44224422, 0x241275e2, 0x0c06140a, 0x000007fe,      // ICON_CUBE_FACE_TOP
    0x7fe00000, 0x50386030, 0x47fe483c, 0x443e443e, 0x443e443e, 0x241e75fe, 0x0c06140e, 0x000007fe,      // ICON_CUBE_FACE_LEFT
    0x7fe00000, 0x50286030, 0x47fe4804, 0x47fe47fe, 0x47fe47fe, 0x27fe77fe, 0x0ffe17fe, 0x000007fe,      // ICON_CUBE_FACE_FRONT
    0x7fe00000, 0x50286030, 0x47fe4804, 0x44224402, 0x44224422, 0x3ff27fe2, 0x0ffe1ffa, 0x000007fe,      // ICON_CUBE_FACE_BOTTOM
    0x7fe00000, 0x70286030, 0x7ffe7804, 0x7c227c02, 0x7c227c22, 0x3c127de2, 0x0c061c0a, 0x000007fe,      // ICON_CUBE_FACE_RIGHT
    0x7fe00000, 0x7fe87ff0, 0x7ffe7fe4, 0x7fe27fe2, 0x7fe27fe2, 0x24127fe2, 0x0c06140a, 0x000007fe,      // ICON_CUBE_FACE_BACK
    0x00000000, 0x2a0233fe, 0x22022602, 0x22022202, 0x2a022602, 0x00a033fe, 0x02080110, 0x00000000,      // ICON_CAMERA
    0x00000000, 0x200c3ffc, 0x000c000c, 0x3ffc000c, 0x30003000, 0x30003000, 0x3ffc3004, 0x00000000,      // ICON_SPECIAL
    0x00000000, 0x0022003e, 0x012201e2, 0x0100013e, 0x01000100, 0x79000100, 0x4f004900, 0x00007800,      // ICON_LINK_NET
    0x00000000, 0x44007c00, 0x45004600, 0x00627cbe, 0x00620022, 0x45007cbe, 0x44004600, 0x00007c00,      // ICON_LINK_BOXES
    0x00000000, 0x0044007c, 0x0010007c, 0x3f100010, 0x3f1021f0, 0x3f100010, 0x3f0021f0, 0x00000000,      // ICON_LINK_MULTI
    0x00000000, 0x0044007c, 0x00440044, 0x0010007c, 0x00100010, 0x44107c10, 0x440047f0, 0x00007c00,      // ICON_LINK
    0x00000000, 0x0044007c, 0x00440044, 0x0000007c, 0x00000010, 0x44007c10, 0x44004550, 0x00007c00,      // ICON_LINK_BROKE
    0x02a00000, 0x22a43ffc, 0x20042004, 0x20042ff4, 0x20042ff4, 0x20042ff4, 0x20042004, 0x00003ffc,      // ICON_TEXT_NOTES
    0x3ffc0000, 0x20042004, 0x245e27c4, 0x27c42444, 0x2004201e, 0x201e2004, 0x20042004, 0x00003ffc,      // ICON_NOTEBOOK
    0x00000000, 0x07e00000, 0x04200420, 0x24243ffc, 0x24242424, 0x24242424, 0x3ffc2424, 0x00000000,      // ICON_SUITCASE
    0x00000000, 0x0fe00000, 0x08200820, 0x40047ffc, 0x7ffc5554, 0x40045554, 0x7ffc4004, 0x00000000,      // ICON_SUITCASE_ZIP
    0x00000000, 0x20043ffc, 0x3ffc2004, 0x13c81008, 0x100813c8, 0x10081008, 0x1ff81008, 0x00000000,      // ICON_MAILBOX
    0x00000000, 0x40027ffe, 0x5ffa5ffa, 0x5ffa5ffa, 0x40025ffa, 0x03c07ffe, 0x1ff81ff8, 0x00000000,      // ICON_MONITOR
    0x0ff00000, 0x6bfe7ffe, 0x7ffe7ffe, 0x68167ffe, 0x08106816, 0x08100810, 0x0ff00810, 0x00000000,      // ICON_PRINTER
    0x3ff80000, 0xfffe2008, 0x870a8002, 0x904a888a, 0x904a904a, 0x870a888a, 0xfffe8002, 0x00000000,      // ICON_PHOTO_CAMERA
    0x0fc00000, 0xfcfe0cd8, 0x8002fffe, 0x84428382, 0x84428442, 0x80028382, 0xfffe8002, 0x00000000,      // ICON_PHOTO_CAMERA_FLASH
    0x00000000, 0x02400180, 0x08100420, 0x20041008, 0x23c42004, 0x22442244, 0x3ffc2244, 0x00000000,      // ICON_HOUSE
    0x00000000, 0x1c700000, 0x3ff83ef8, 0x3ff83ff8, 0x0fe01ff0, 0x038007c0, 0x00000100, 0x00000000,      // ICON_HEART
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0xe000c000,      // ICON_CORNER
    0x00000000, 0x14001c00, 0x15c01400, 0x15401540, 0x155c1540, 0x15541554, 0x1ddc1554, 0x00000000,      // ICON_VERTICAL_BARS
    0x00000000, 0x03000300, 0x1b001b00, 0x1b601b60, 0x1b6c1b60, 0x1b6c1b6c, 0x1b6c1b6c, 0x00000000,      // ICON_VERTICAL_BARS_FILL
    0x00000000, 0x00000000, 0x403e7ffe, 0x7ffe403e, 0x7ffe0000, 0x43fe43fe, 0x00007ffe, 0x00000000,      // ICON_LIFE_BARS
    0x7ffc0000, 0x43844004, 0x43844284, 0x43844004, 0x42844284, 0x42844284, 0x40044384, 0x00007ffc,      // ICON_INFO
    0x40008000, 0x10002000, 0x04000800, 0x01000200, 0x00400080, 0x00100020, 0x00040008, 0x00010002,      // ICON_CROSSLINE
    0x00000000, 0x1ff01ff0, 0x18301830, 0x1f001830, 0x03001f00, 0x00000300, 0x03000300, 0x00000000,      // ICON_HELP
    0x3ff00000, 0x2abc3550, 0x2aac3554, 0x2aac3554, 0x2aac3554, 0x2aac3554, 0x2aac3554, 0x00003ffc,      // ICON_FILETYPE_ALPHA
    0x3ff00000, 0x201c2010, 0x22442184, 0x28142424, 0x29942814, 0x2ff42994, 0x20042004, 0x00003ffc,      // ICON_FILETYPE_HOME
    0x07fe0000, 0x04020402, 0x7fe20402, 0x44224422, 0x44224422, 0x402047fe, 0x40204020, 0x00007fe0,      // ICON_LAYERS_VISIBLE
    0x07fe0000, 0x04020402, 0x7c020402, 0x44024402, 0x44024402, 0x402047fe, 0x40204020, 0x00007fe0,      // ICON_LAYERS
    0x00000000, 0x40027ffe, 0x7ffe4002, 0x40024002, 0x40024002, 0x40024002, 0x7ffe4002, 0x00000000,      // ICON_WINDOW
    0x09100000, 0x09f00910, 0x09100910, 0x00000910, 0x24a2779e, 0x27a224a2, 0x709e20a2, 0x00000000,      // ICON_HIDPI
    0x3ff00000, 0x201c2010, 0x2a842e84, 0x2e842a84, 0x2ba42004, 0x2aa42aa4, 0x20042ba4, 0x00003ffc,      // ICON_FILETYPE_BINARY
    0x00000000, 0x00000000, 0x00120012, 0x4a5e4bd2, 0x485233d2, 0x00004bd2, 0x00000000, 0x00000000,      // ICON_HEX
    0x01800000, 0x381c0660, 0x23c42004, 0x23c42044, 0x13c82204, 0x08101008, 0x02400420, 0x00000180,      // ICON_SHIELD
    0x007e0000, 0x20023fc2, 0x40227fe2, 0x400a403a, 0x400a400a, 0x400a400a, 0x4008400e, 0x00007ff8,      // ICON_FILE_NEW
    0x00000000, 0x0042007e, 0x40027fc2, 0x44024002, 0x5f024402, 0x44024402, 0x7ffe4002, 0x00000000,      // ICON_FOLDER_ADD
    0x44220000, 0x12482244, 0xf3cf0000, 0x14280420, 0x48122424, 0x08100810, 0x1ff81008, 0x03c00420,      // ICON_ALARM
    0x0aa00000, 0x1ff80aa0, 0x1068700e, 0x1008706e, 0x1008700e, 0x1008700e, 0x0aa01ff8, 0x00000aa0,      // ICON_CPU
    0x07e00000, 0x04201db8, 0x04a01c38, 0x04a01d38, 0x04a01d38, 0x04a01d38, 0x04201d38, 0x000007e0,      // ICON_ROM
    0x00000000, 0x03c00000, 0x3c382ff0, 0x3c04380c, 0x01800000, 0x03c003c0, 0x00000180, 0x00000000,      // ICON_STEP_OVER
    0x01800000, 0x01800180, 0x01800180, 0x03c007e0, 0x00000180, 0x01800000, 0x03c003c0, 0x00000180,      // ICON_STEP_INTO
    0x01800000, 0x07e003c0, 0x01800180, 0x01800180, 0x00000180, 0x01800000, 0x03c003c0, 0x00000180,      // ICON_STEP_OUT
    0x00000000, 0x0ff003c0, 0x181c1c34, 0x303c301c, 0x30003000, 0x1c301800, 0x03c00ff0, 0x00000000,      // ICON_RESTART
    0x00000000, 0x00000000, 0x07e003c0, 0x0ff00ff0, 0x0ff00ff0, 0x03c007e0, 0x00000000, 0x00000000,      // ICON_BREAKPOINT_ON
    0x00000000, 0x00000000, 0x042003c0, 0x08100810, 0x08100810, 0x03c00420, 0x00000000, 0x00000000,      // ICON_BREAKPOINT_OFF
    0x00000000, 0x00000000, 0x1ff81ff8, 0x1ff80000, 0x00001ff8, 0x1ff81ff8, 0x00000000, 0x00000000,      // ICON_BURGER_MENU
    0x00000000, 0x00000000, 0x00880070, 0x0c880088, 0x1e8810f8, 0x3e881288, 0x00000000, 0x00000000,      // ICON_CASE_SENSITIVE
    0x00000000, 0x02000000, 0x07000a80, 0x07001fc0, 0x02000a80, 0x00300030, 0x00000000, 0x00000000,      // ICON_REG_EXP
    0x00000000, 0x0042007e, 0x40027fc2, 0x40024002, 0x40024002, 0x40024002, 0x7ffe4002, 0x00000000,      // ICON_FOLDER
    0x3ff00000, 0x201c2010, 0x20042004, 0x20042004, 0x20042004, 0x20042004, 0x20042004, 0x00003ffc,      // ICON_FILE
    0x1ff00000, 0x20082008, 0x17d02fe8, 0x05400ba0, 0x09200540, 0x23881010, 0x2fe827c8, 0x00001ff0,      // ICON_SAND_TIMER
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_220
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_221
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_222
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_223
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_224
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_225
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_226
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_227
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_228
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_229
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_230
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_231
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_232
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_233
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_234
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_235
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_236
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_237
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_238
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_239
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_240
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_241
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_242
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_243
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_244
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_245
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_246
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_247
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_248
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_249
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_250
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_251
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_252
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_253
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_254
    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,      // ICON_255
};
            guiIconsPtr = guiIcons;
            guiStyle = new uint [ RAYGUI_MAX_CONTROLS * (RAYGUI_MAX_PROPS_BASE + RAYGUI_MAX_PROPS_EXTENDED) ];
            for (int i = 0 ; i < guiStyle.Length ; i++)
            {
                guiStyle [ i ] = 0;
            }
            guiFont = new Font();
        }
        // Gui draw text using default font

        static Rectangle GetTextBounds(int control , Rectangle bounds)
        {
            Rectangle textBounds = bounds;

            textBounds.x = bounds.x + GuiGetStyle(control , BORDER_WIDTH);
            textBounds.y = bounds.y + GuiGetStyle(control , BORDER_WIDTH) + GuiGetStyle(control , TEXT_PADDING);
            textBounds.width = bounds.width - 2 * GuiGetStyle(control , BORDER_WIDTH) - 2 * GuiGetStyle(control , TEXT_PADDING);
            textBounds.height = bounds.height - 2 * GuiGetStyle(control , BORDER_WIDTH) - 2 * GuiGetStyle(control , TEXT_PADDING);

            // Consider TEXT_PADDING properly, depends on control type and TEXT_ALIGNMENT
            // TODO: Special cases (no label): COMBOBOX, DROPDOWNBOX, LISTVIEW (scrollbar?)
            // More special cases (label on side): CHECKBOX, SLIDER, VALUEBOX, SPINNER
            switch (control)
            {
                default:
                    {
                        if (GuiGetStyle(control , TEXT_ALIGNMENT) == TEXT_ALIGN_RIGHT) textBounds.x -= GuiGetStyle(control , TEXT_PADDING);
                        else textBounds.x += GuiGetStyle(control , TEXT_PADDING);
                    }
                    break;
            }

            return textBounds;
        }

        public static Color Fade(Color color , float alpha)
        {
            if (alpha < 0.0f) alpha = 0.0f;
            else if (alpha > 1.0f) alpha = 1.0f;

            Color result = new Color(color.r , color.g , color.b , (byte)(255.0f * alpha));

            return result;
        }
        public static Color GetColor(int hexValue)
        {
            Color color;

            color.r = (byte)((hexValue >> 24) & 0xFF);
            color.g = (byte)((hexValue >> 16) & 0xFF);
            color.b = (byte)((hexValue >> 8) & 0xFF);
            color.a = (byte)(hexValue & 0xFF);

            return color;
        }
        public static Color GetColor(uint hexValue)
        {
            Color color;

            color.r = (byte)((hexValue >> 24) & 0xFF);
            color.g = (byte)((hexValue >> 16) & 0xFF);
            color.b = (byte)((hexValue >> 8) & 0xFF);
            color.a = (byte)(hexValue & 0xFF);

            return color;
        }

        // Toggle Button control, returns true when active
        public static bool GuiToggle(Rectangle bounds , string text , bool active)
        {
            int state = (int)guiState;

            // Update control
            //--------------------------------------------------------------------
            if ((state != STATE_DISABLED) && !guiLocked && !guiSliderDragging)
            {
                Vector2 mousePoint = Raylib.GetMousePosition();

                // Check toggle button state
                if (Raylib.CheckCollisionPointRec(mousePoint , bounds))
                {
                    if (Raylib.IsMouseButtonDown(MouseButton.MOUSE_LEFT_BUTTON)) state = STATE_PRESSED;
                    else if (Raylib.IsMouseButtonReleased(MouseButton.MOUSE_LEFT_BUTTON))
                    {
                        state = STATE_NORMAL;
                        active = !active;
                    }
                    else state = STATE_FOCUSED;
                }
            }
            //--------------------------------------------------------------------

            // Draw control
            //--------------------------------------------------------------------
            if (state == STATE_NORMAL)
            {
                GuiDrawRectangle(bounds , (int)GuiGetStyle(TOGGLE , BORDER_WIDTH) , Fade(GetColor(GuiGetStyle(TOGGLE , (active ? BORDER_COLOR_PRESSED : (BORDER + state * 3)))) , guiAlpha) , Fade(GetColor(GuiGetStyle(TOGGLE , (active ? BASE_COLOR_PRESSED : (BASE + state * 3)))) , guiAlpha));
                GuiDrawText(text , GetTextBounds(TOGGLE , bounds) , (int)GuiGetStyle(TOGGLE , TEXT_ALIGNMENT) , Fade(GetColor(GuiGetStyle(TOGGLE , (active ? TEXT_COLOR_PRESSED : (TEXT + state * 3)))) , guiAlpha));
            }
            else
            {
                GuiDrawRectangle(bounds , (int)GuiGetStyle(TOGGLE , BORDER_WIDTH) , Fade(GetColor(GuiGetStyle(TOGGLE , BORDER + state * 3)) , guiAlpha) , Fade(GetColor(GuiGetStyle(TOGGLE , BASE + state * 3)) , guiAlpha));
                GuiDrawText(text , GetTextBounds(TOGGLE , bounds) , (int)GuiGetStyle(TOGGLE , TEXT_ALIGNMENT) , Fade(GetColor(GuiGetStyle(TOGGLE , TEXT + state * 3)) , guiAlpha));
            }

            if (state == STATE_FOCUSED) GuiTooltip(bounds);
            //--------------------------------------------------------------------

            return active;
        }

        /**
         * Porter note: String in C# is UTF-8 already. 
         **/
        // Get next codepoint in a UTF-8 encoded text, scanning until '\0' is found
        // When a invalid UTF-8 byte is encountered we exit as soon as possible and a '?'(0x3f) codepoint is returned
        // Total number of bytes processed are returned as a parameter
        // NOTE: the standard says U+FFFD should be returned in case of errors
        // but that character is not supported by the default font in raylib
        public static int GetCodepointNext(ReadonlyString text , ref int codepointSize)
        {
            codepointSize = 1;
            return text [ 0 ];
            //string ptr = text;
            //int codepoint = 0x3f;       // Codepoint (defaults to '?')
            //codepointSize = 1;

            //// Get current codepoint and bytes processed
            //if (0xf0 == (0xf8 & ptr [ 0 ]))
            //{
            //    // 4 byte UTF-8 codepoint
            //    if ((((ptr [ 1 ] & 0xC0) ^ 0x80) != 0) || (((ptr [ 2 ] & 0xC0) ^ 0x80) != 0) || ((ptr [ 3 ] & 0xC0) ^ 0x80) != 0)
            //    {
            //        return codepoint;
            //    } //10xxxxxx checks
            //    codepoint = ((0x07 & ptr [ 0 ]) << 18) | ((0x3f & ptr [ 1 ]) << 12) | ((0x3f & ptr [ 2 ]) << 6) | (0x3f & ptr [ 3 ]);
            //    codepointSize = 4;
            //}
            //else if (0xe0 == (0xf0 & ptr [ 0 ]))
            //{
            //    // 3 byte UTF-8 codepoint */
            //    if (((ptr [ 1 ] & 0xC0) ^ 0x80) != 0 || ((ptr [ 2 ] & 0xC0) ^ 0x80) != 0) { return codepoint; } //10xxxxxx checks
            //    codepoint = ((0x0f & ptr [ 0 ]) << 12) | ((0x3f & ptr [ 1 ]) << 6) | (0x3f & ptr [ 2 ]);
            //    codepointSize = 3;
            //}
            //else if (0xc0 == (0xe0 & ptr [ 0 ]))
            //{
            //    // 2 byte UTF-8 codepoint
            //    if (((ptr [ 1 ] & 0xC0) ^ 0x80) != 0) { return codepoint; } //10xxxxxx checks
            //    codepoint = ((0x1f & ptr [ 0 ]) << 6) | (0x3f & ptr [ 1 ]);
            //    codepointSize = 2;
            //}
            //else if (0x00 == (0x80 & ptr [ 0 ]))
            //{
            //    // 1 byte UTF-8 codepoint
            //    codepoint = ptr [ 0 ];
            //    codepointSize = 1;
            //}


            //return codepoint;
        }
        // Gui get text width considering icon
        public static int GetTextWidth(string text)
        {
            Vector2 textSize = default;
            int textIconOffset = 0;

            if ((text != null) && (text.Length > 0))
            {
                if (text [ 0 ] == '#')
                {
                    for (int i = 1 ; (i < 5) && (i < text.Length) ; i++)
                    {
                        if (text [ i ] == '#')
                        {
                            textIconOffset = i;
                            break;
                        }
                    }
                }

                text += textIconOffset;

                // Make sure guiFont is set, GuiGetStyle() initializes it lazynessly
                float fontSize = (float)GuiGetStyle(DEFAULT , TEXT_SIZE);

                // Custom MeasureText() implementation
                if ((guiFont.texture.id > 0) && (text != null))
                {
                    // Get size in bytes of text, considering end of line and line break
                    int size = text.Length;

                    float scaleFactor = fontSize / (float)guiFont.baseSize;
                    textSize.Y = (float)guiFont.baseSize * scaleFactor;
                    float glyphWidth = 0.0f;

                    for (int i = 0, codepointSize = 1 ; i < size ; i += codepointSize)
                    {
                        int codepoint = text [ i ];
                        int codepointIndex = Raylib.GetGlyphIndex(guiFont , codepoint);
                        unsafe
                        {
                            if (guiFont.glyphs [ codepointIndex ].advanceX == 0)
                                glyphWidth = ((float)guiFont.recs [ codepointIndex ].width * scaleFactor + (float)GuiGetStyle(DEFAULT , TEXT_SPACING));
                            else glyphWidth = ((float)guiFont.glyphs [ codepointIndex ].advanceX * scaleFactor + GuiGetStyle(DEFAULT , TEXT_SPACING));

                        }

                        textSize.X += glyphWidth;
                    }
                }

                if (textIconOffset > 0) textSize.X += (RAYGUI_ICON_SIZE - ICON_TEXT_PADDING);
            }

            return (int)textSize.X;
        }
        static int GetTextWidth(ReadonlyString text)
        {
            Vector2 textSize = default;
            int textIconOffset = 0;

            if ((text.Ref != null) && (text.Length > 0))
            {
                if (text [ 0 ] == '#')
                {
                    for (int i = 1 ; (i < 5) && (i < text.Length) ; i++)
                    {
                        if (text [ i ] == '#')
                        {
                            textIconOffset = i;
                            break;
                        }
                    }
                }

                text.Start += textIconOffset;

                // Make sure guiFont is set, GuiGetStyle() initializes it lazynessly
                float fontSize = (float)GuiGetStyle(DEFAULT , TEXT_SIZE);

                // Custom MeasureText() implementation
                if ((guiFont.texture.id > 0) && (text.Ref != null))
                {
                    // Get size in bytes of text, considering end of line and line break
                    int size = text.Length;

                    float scaleFactor = fontSize / (float)guiFont.baseSize;
                    textSize.Y = (float)guiFont.baseSize * scaleFactor;
                    float glyphWidth = 0.0f;

                    for (int i = 0, codepointSize = 1 ; i < size ; i += codepointSize)
                    {
                        int codepoint = text [ i ];
                        int codepointIndex = Raylib.GetGlyphIndex(guiFont , codepoint);
                        unsafe
                        {
                            if (guiFont.glyphs [ codepointIndex ].advanceX == 0)
                                glyphWidth = ((float)guiFont.recs [ codepointIndex ].width * scaleFactor + (float)GuiGetStyle(DEFAULT , TEXT_SPACING));
                            else glyphWidth = ((float)guiFont.glyphs [ codepointIndex ].advanceX * scaleFactor + GuiGetStyle(DEFAULT , TEXT_SPACING));

                        }

                        textSize.X += glyphWidth;
                    }
                }

                if (textIconOffset > 0) textSize.X += (RAYGUI_ICON_SIZE - ICON_TEXT_PADDING);
            }

            return (int)textSize.X;
        }

        static int TextToInteger(char [ ] text)
        {
            int value = 0;
            int sign = 1;
            int s = 0;
            if ((text [ 0 ] == '+') || (text [ 0 ] == '-'))
            {
                if (text [ 0 ] == '-') sign = -1;
                s = 1;
            }

            for (int i = s ; ((text [ i ] >= '0') && (text [ i ] <= '9')) ; ++i) value = value * 10 + (int)(text [ i ] - '0');

            return value * sign;
        }
        public static ReadonlyString GetTextIcon(ReadonlyString text , ref int iconId)
        {
            iconId = -1;
            if (text [ 0 ] == '#')     // Maybe we have an icon!
            {
                char [ ] iconValue = new char [ 4 ];  // Maximum length for icon value: 3 digits + '\0'

                int pos = 1;
                while ((pos < 4) && (text [ pos ] >= '0') && (text [ pos ] <= '9'))
                {
                    iconValue [ pos - 1 ] = text [ pos ];
                    pos++;
                }

                if (text [ pos ] == '#')
                {
                    iconId = TextToInteger(iconValue);

                    // Move text pointer after icon
                    // WARNING: If only icon provided, it could point to EOL character: '\0'
                    if (iconId >= 0)
                    {
                        text.Start += (pos + 1);
                        text.Length -= (pos + 1);
                    }
                }
            }

            return text;
        }
        public static uint [ ] guiIconsPtr;
        public static bool BIT_CHECK(int a , int b) => ((a) & (1u << (b))) != 0;
        public static bool BIT_CHECK(uint a , int b) => ((a) & (1u << (b))) != 0;
        public static void GuiDrawIcon(int iconId , int posX , int posY , int pixelSize , Color color)
        {

            for (int i = 0, y = 0 ; i < RAYGUI_ICON_SIZE * RAYGUI_ICON_SIZE / 32 ; i++)
            {
                for (int k = 0 ; k < 32 ; k++)
                {
                    if (BIT_CHECK(guiIconsPtr [ iconId * RAYGUI_ICON_DATA_ELEMENTS + i ] , k))
                    {
                        Raylib.DrawRectangle(posX + (k % RAYGUI_ICON_SIZE) * pixelSize , posY + y * pixelSize , pixelSize , pixelSize , color);

                    }

                    if ((k == 15) || (k == 31)) y++;
                }
            }
        }
        public static void GuiDrawText(string text , Rectangle bounds , int alignment , Color tint)
        {

            uint alignmentVertical = GuiGetStyle(TEXTBOX , TEXT_ALIGNMENT_VERTICAL);

            // We process the text lines one by one
            if ((text != null) && (text.Length > 0))
            {
                // Get text lines ('\n' delimiter) to process lines individually
                // NOTE: We can't use GuiTextSplit() because it can be already used before calling
                // GuiDrawText() and static buffer would be overriden :(
                int lineCount = 0;
                //const char** lines = GetTextLines(text , &lineCount);
                //string [ ] lines = text.Split('\n');
                text.AsSpan();
                ReadOnlySpan<char> chars = text;
                var lines = chars.SplitSingleChar('\n');
                lineCount = lines.Item1;
                //Rectangle textBounds = GetTextBounds(LABEL, bounds);
                float totalHeight = (float)(lineCount * GuiGetStyle(DEFAULT , TEXT_SIZE) + (lineCount - 1) * GuiGetStyle(DEFAULT , TEXT_SIZE) / 2);
                float posOffsetY = 0;

                for (int i = 0 ; i < lineCount ; i++)
                {
                    int iconId = 0;
                    ReadonlyString Line = new ReadonlyString { Ref = text , Start = lines.Item2 [ i ].Item1 , Length = lines.Item2 [ i ].Item2 };
                    Line = GetTextIcon(Line , ref iconId);      // Check text for icon and move cursor

                    // Get text position depending on alignment and iconId
                    //---------------------------------------------------------------------------------
                    Vector2 position = new Vector2(bounds.x , bounds.y);

                    // NOTE: We get text size after icon has been processed
                    // WARNING: GetTextWidth() also processes text icon to get width! -> Really needed?
                    int textSizeX = GetTextWidth(Line);

                    // If text requires an icon, add size to measure
                    if (iconId >= 0)
                    {
                        textSizeX += RAYGUI_ICON_SIZE * (int)guiIconScale;

                        // WARNING: If only icon provided, text could be pointing to EOF character: '\0'
                        if ((Line.Ref != null) && (Line.Length > 0)) textSizeX += ICON_TEXT_PADDING;
                    }

                    // Check guiTextAlign global variables
                    switch (alignment)
                    {
                        case TEXT_ALIGN_LEFT: position.X = bounds.x; break;
                        case TEXT_ALIGN_CENTER: position.X = bounds.x + bounds.width / 2 - textSizeX / 2; break;
                        case TEXT_ALIGN_RIGHT: position.X = bounds.x + bounds.width - textSizeX; break;
                        default: break;
                    }

                    switch (alignmentVertical)
                    {
                        case 0: position.Y = bounds.y + posOffsetY + bounds.height / 2 - totalHeight / 2 + TEXT_VALIGN_PIXEL_OFFSET(bounds.height); break;  // CENTERED
                        case 1: position.Y = bounds.y + posOffsetY; break;  // UP
                        case 2: position.Y = bounds.y + posOffsetY + bounds.height - totalHeight + TEXT_VALIGN_PIXEL_OFFSET(bounds.height); break;  // DOWN
                        default: break;
                    }

                    // NOTE: Make sure we get pixel-perfect coordinates,
                    // In case of decimals we got weird text positioning
                    position.X = (float)((int)position.X);
                    position.Y = (float)((int)position.Y);
                    //---------------------------------------------------------------------------------

                    // Draw text (with icon if available)
                    //---------------------------------------------------------------------------------
                    //#if !defined(RAYGUI_NO_ICONS)
                    if (iconId >= 0)
                    {
                        // NOTE: We consider icon height, probably different than text size
                        GuiDrawIcon(iconId , (int)position.X , (int)(bounds.y + bounds.height / 2 - RAYGUI_ICON_SIZE * guiIconScale / 2 + TEXT_VALIGN_PIXEL_OFFSET(bounds.height)) , (int)guiIconScale , tint);
                        position.X += (RAYGUI_ICON_SIZE * guiIconScale + ICON_TEXT_PADDING);
                    }
                    //#endif
                    //DrawTextEx(guiFont, text, position, (float)GuiGetStyle(DEFAULT, TEXT_SIZE), (float)GuiGetStyle(DEFAULT, TEXT_SPACING), tint);

                    // Get size in bytes of text,
                    // considering end of line and line break
                    int size = Line.Length;
                    //for (int c = 0 ; (c<lines.Length) && (lines [ i ] [ c ] != '\n') ; c++, size++) { }
                    float scaleFactor = (float)GuiGetStyle(DEFAULT , TEXT_SIZE) / guiFont.baseSize;

                    int textOffsetY = 0;
                    float textOffsetX = 0.0f;
                    for (int c = 0 ; c < size ; c++)
                    {
                        int codepoint = Line [ c ];
                        int index = Raylib.GetGlyphIndex(guiFont , codepoint);

                        // NOTE: Normally we exit the decoding sequence as soon as a bad byte is found (and return 0x3f)
                        // but we need to draw all of the bad bytes using the '?' symbol moving one byte
                        //if (codepoint == 0x3f) codepointSize = 1;

                        if (codepoint == '\n') break;   // WARNING: Lines are already processed manually, no need to keep drawing after this codepoint
                        else
                        {
                            if ((codepoint != ' ') && (codepoint != '\t'))
                            {
                                unsafe
                                {
                                    // Draw only required text glyphs fitting the bounds.width
                                    if (textOffsetX < (bounds.width - guiFont.recs [ index ].width))
                                    {
                                        Raylib.DrawTextCodepoint(guiFont , codepoint , new Vector2(position.X + textOffsetX , position.Y + textOffsetY) , (float)GuiGetStyle(DEFAULT , TEXT_SIZE) , tint);
                                    }

                                }
                            }
                            unsafe
                            {
                                if (guiFont.glyphs [ index ].advanceX == 0)
                                    textOffsetX += ((float)guiFont.recs [ index ].width * scaleFactor + (float)GuiGetStyle(DEFAULT , TEXT_SPACING));
                                else textOffsetX += ((float)guiFont.glyphs [ index ].advanceX * scaleFactor + (float)GuiGetStyle(DEFAULT , TEXT_SPACING));

                            }
                        }
                    }

                    // TODO: Allow users to set line spacing for text: GuiSetStyle(TEXTBOX, TEXT_LINES_SPACING, x)
                    posOffsetY += (float)GuiGetStyle(DEFAULT , TEXT_SIZE) * 1.5f;
                    //---------------------------------------------------------------------------------
                }
            }
        }
        public static void GuiLabel(Rectangle bounds , string text)
        {
            GuiState state = guiState;

            // Update control
            //--------------------------------------------------------------------
            //...
            //--------------------------------------------------------------------

            // Draw control
            //--------------------------------------------------------------------
            GuiDrawText(text , GetTextBounds(LABEL , bounds) , (int)GuiGetStyle(LABEL , TEXT_ALIGNMENT) ,
                Fade(GetColor(GuiGetStyle(LABEL , TEXT + ((int)state * 3))) , guiAlpha));
            //--------------------------------------------------------------------
        }

        // Button control, returns true when clicked
        public static bool GuiButton(Rectangle bounds , string text)
        {
            int state = (int)guiState;
            bool pressed = false;

            // Update control
            //--------------------------------------------------------------------
            if ((state != STATE_DISABLED) && !guiLocked && !guiSliderDragging)
            {
                Vector2 mousePoint = Raylib.GetMousePosition();

                // Check button state
                if (Raylib.CheckCollisionPointRec(mousePoint , bounds))
                {
                    if (Raylib.IsMouseButtonDown(MouseButton.MOUSE_LEFT_BUTTON)) state = STATE_PRESSED;
                    else state = STATE_FOCUSED;

                    if (Raylib.IsMouseButtonReleased(MouseButton.MOUSE_LEFT_BUTTON)) pressed = true;
                }
            }
            //--------------------------------------------------------------------

            // Draw control
            //--------------------------------------------------------------------
            GuiDrawRectangle(bounds ,
                             (int)GuiGetStyle(BUTTON , BORDER_WIDTH) ,
                             Fade(GetColor(GuiGetStyle(BUTTON , BORDER + (state * 3))) , guiAlpha) ,
                             Fade(GetColor(GuiGetStyle(BUTTON , BASE + (state * 3))) , guiAlpha));
            GuiDrawText(text ,
                        GetTextBounds(BUTTON , bounds) ,
                        (int)GuiGetStyle(BUTTON , TEXT_ALIGNMENT) ,
                        Fade(GetColor(GuiGetStyle(BUTTON , TEXT + (state * 3))) , guiAlpha));

            if (state == STATE_FOCUSED) GuiTooltip(bounds);
            //------------------------------------------------------------------

            return pressed;
        }

        public static Font GuiGetFont()
        {
            return guiFont;
        }

        // Panel control
        public static void GuiPanel(Rectangle bounds , string text)
        {
            GuiState state = guiState;

            // Text will be drawn as a header bar (if provided)
            Rectangle statusBar = new Rectangle(bounds.x , bounds.y , bounds.width , (float)RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT);
            if ((text != null) && (bounds.height < RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT * 2.0f)) bounds.height = RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT * 2.0f;

            if (text != null)
            {
                // Move panel bounds after the header bar
                bounds.y += (float)RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT - 1;
                bounds.height -= (float)RAYGUI_WINDOWBOX_STATUSBAR_HEIGHT + 1;
            }

            // Draw control
            //--------------------------------------------------------------------
            if (text != null) GuiStatusBar(statusBar , text);  // Draw panel header as status bar

            GuiDrawRectangle(bounds ,
                             RAYGUI_PANEL_BORDER_WIDTH ,
                             Fade(GetColor(GuiGetStyle(DEFAULT , ((int)state == STATE_DISABLED) ? BORDER_COLOR_DISABLED : LINE_COLOR)) , guiAlpha) ,
                             Fade(GetColor(GuiGetStyle(DEFAULT , ((int)state == STATE_DISABLED) ? BASE_COLOR_DISABLED : BACKGROUND_COLOR)) , guiAlpha));
            //--------------------------------------------------------------------
        }

        // Status Bar control
        public static void GuiStatusBar(Rectangle bounds , string text)
        {
            GuiState state = guiState;

            // Draw control
            //--------------------------------------------------------------------
            GuiDrawRectangle(bounds , (int)GuiGetStyle(STATUSBAR , BORDER_WIDTH) , Fade(GetColor(GuiGetStyle(STATUSBAR , ((int)state != STATE_DISABLED) ? BORDER_COLOR_NORMAL : BORDER_COLOR_DISABLED)) , guiAlpha) ,
                             Fade(GetColor(GuiGetStyle(STATUSBAR , ((int)state != STATE_DISABLED) ? BASE_COLOR_NORMAL : BASE_COLOR_DISABLED)) , guiAlpha));
            GuiDrawText(text , GetTextBounds(STATUSBAR , bounds) , (int)GuiGetStyle(STATUSBAR , TEXT_ALIGNMENT) , Fade(GetColor(GuiGetStyle(STATUSBAR , ((int)state != STATE_DISABLED) ? TEXT_COLOR_NORMAL : TEXT_COLOR_DISABLED)) , guiAlpha));
            //--------------------------------------------------------------------
        }

        // Draw tooltip using control bounds
        public static void GuiTooltip(Rectangle controlRec)
        {
            if (!guiLocked && guiTooltip && (guiTooltipPtr != null) && !guiSliderDragging)
            {
                Vector2 textSize = Raylib.MeasureTextEx(GuiGetFont() , guiTooltipPtr , GuiGetStyle(DEFAULT , TEXT_SIZE) , GuiGetStyle(DEFAULT , TEXT_SPACING));

                if ((controlRec.x + textSize.X + 16) > Raylib.GetScreenWidth()) controlRec.x -= (textSize.X + 16 - controlRec.width);

                GuiPanel(new Rectangle(controlRec.x , controlRec.y + controlRec.height + 4 , textSize.Y + 16 , GuiGetStyle(DEFAULT , TEXT_SIZE) + 8.0f) , null);

                uint textPadding = GuiGetStyle(LABEL , TEXT_PADDING);
                uint textAlignment = GuiGetStyle(LABEL , TEXT_ALIGNMENT);
                GuiSetStyle(LABEL , TEXT_PADDING , 0);
                GuiSetStyle(LABEL , TEXT_ALIGNMENT , TEXT_ALIGN_CENTER);
                GuiLabel(new Rectangle(controlRec.x , controlRec.y + controlRec.height + 4 , textSize.X + 16 , GuiGetStyle(DEFAULT , TEXT_SIZE) + 8.0f) , guiTooltipPtr);
                GuiSetStyle(LABEL , TEXT_ALIGNMENT , textAlignment);
                GuiSetStyle(LABEL , TEXT_PADDING , textPadding);
            }
        }
        // Gui draw rectangle using default raygui plain style with borders
        public static void GuiDrawRectangle(Rectangle rec , int borderWidth , Color borderColor , Color color)
        {
            if (color.a > 0)
            {
                // Draw rectangle filled with color
                Raylib.DrawRectangle((int)rec.x , (int)rec.y , (int)rec.width , (int)rec.height , color);
            }

            if (borderWidth > 0)
            {
                // Draw rectangle border lines with color
                Raylib.DrawRectangle((int)rec.x , (int)rec.y , (int)rec.width , borderWidth , borderColor);
                Raylib.DrawRectangle((int)rec.x , (int)rec.y + borderWidth , borderWidth , (int)rec.height - 2 * borderWidth , borderColor);
                Raylib.DrawRectangle((int)rec.x + (int)rec.width - borderWidth , (int)rec.y + borderWidth , borderWidth , (int)rec.height - 2 * borderWidth , borderColor);
                Raylib.DrawRectangle((int)rec.x , (int)rec.y + (int)rec.height - borderWidth , (int)rec.width , borderWidth , borderColor);
            }
        }

        public static void GuiSetStyle(int control , int property , uint value)
        {
            if (!guiStyleLoaded) GuiLoadStyleDefault();
            guiStyle [ control * (RAYGUI_MAX_PROPS_BASE + RAYGUI_MAX_PROPS_EXTENDED) + property ] = value;

            // Default properties are propagated to all controls
            if ((control == 0) && (property < RAYGUI_MAX_PROPS_BASE))
            {
                for (int i = 1 ; i < RAYGUI_MAX_CONTROLS ; i++) guiStyle [ i * (RAYGUI_MAX_PROPS_BASE + RAYGUI_MAX_PROPS_EXTENDED) + property ] = value;
            }
        }
        public static void GuiLoadStyleDefault()
        {
            // We set this variable first to avoid cyclic function calls
            // when calling GuiSetStyle() and GuiGetStyle()
            guiStyleLoaded = true;

            // Initialize default LIGHT style property values
            GuiSetStyle(DEFAULT , BORDER_COLOR_NORMAL , 0x838383ff);
            GuiSetStyle(DEFAULT , BASE_COLOR_NORMAL , 0xc9c9c9ff);
            GuiSetStyle(DEFAULT , TEXT_COLOR_NORMAL , 0x686868ff);
            GuiSetStyle(DEFAULT , BORDER_COLOR_FOCUSED , 0x5bb2d9ff);
            GuiSetStyle(DEFAULT , BASE_COLOR_FOCUSED , 0xc9effeff);
            GuiSetStyle(DEFAULT , TEXT_COLOR_FOCUSED , 0x6c9bbcff);
            GuiSetStyle(DEFAULT , BORDER_COLOR_PRESSED , 0x0492c7ff);
            GuiSetStyle(DEFAULT , BASE_COLOR_PRESSED , 0x97e8ffff);
            GuiSetStyle(DEFAULT , TEXT_COLOR_PRESSED , 0x368bafff);
            GuiSetStyle(DEFAULT , BORDER_COLOR_DISABLED , 0xb5c1c2ff);
            GuiSetStyle(DEFAULT , BASE_COLOR_DISABLED , 0xe6e9e9ff);
            GuiSetStyle(DEFAULT , TEXT_COLOR_DISABLED , 0xaeb7b8ff);
            GuiSetStyle(DEFAULT , BORDER_WIDTH , 1);                       // WARNING: Some controls use other values
            GuiSetStyle(DEFAULT , TEXT_PADDING , 0);                       // WARNING: Some controls use other values
            GuiSetStyle(DEFAULT , TEXT_ALIGNMENT , TEXT_ALIGN_CENTER); // WARNING: Some controls use other values

            // Initialize control-specific property values
            // NOTE: Those properties are in default list but require specific values by control type
            GuiSetStyle(LABEL , TEXT_ALIGNMENT , TEXT_ALIGN_LEFT);
            GuiSetStyle(BUTTON , BORDER_WIDTH , 2);
            GuiSetStyle(SLIDER , TEXT_PADDING , 4);
            GuiSetStyle(CHECKBOX , TEXT_PADDING , 4);
            GuiSetStyle(CHECKBOX , TEXT_ALIGNMENT , TEXT_ALIGN_RIGHT);
            GuiSetStyle(TEXTBOX , TEXT_PADDING , 4);
            GuiSetStyle(TEXTBOX , TEXT_ALIGNMENT , TEXT_ALIGN_LEFT);
            GuiSetStyle(VALUEBOX , TEXT_PADDING , 0);
            GuiSetStyle(VALUEBOX , TEXT_ALIGNMENT , TEXT_ALIGN_LEFT);
            GuiSetStyle(SPINNER , TEXT_PADDING , 0);
            GuiSetStyle(SPINNER , TEXT_ALIGNMENT , TEXT_ALIGN_LEFT);
            GuiSetStyle(STATUSBAR , TEXT_PADDING , 8);
            GuiSetStyle(STATUSBAR , TEXT_ALIGNMENT , TEXT_ALIGN_LEFT);

            // Initialize extended property values
            // NOTE: By default, extended property values are initialized to 0
            GuiSetStyle(DEFAULT , TEXT_SIZE , 10);                // DEFAULT, shared by all controls
            GuiSetStyle(DEFAULT , TEXT_SPACING , 1);              // DEFAULT, shared by all controls
            GuiSetStyle(DEFAULT , LINE_COLOR , 0x90abb5ff);       // DEFAULT specific property
            GuiSetStyle(DEFAULT , BACKGROUND_COLOR , 0xf5f5f5ff); // DEFAULT specific property
            GuiSetStyle(TOGGLE , GROUP_PADDING , 2);
            GuiSetStyle(SLIDER , SLIDER_WIDTH , 16);
            GuiSetStyle(SLIDER , SLIDER_PADDING , 1);
            GuiSetStyle(PROGRESSBAR , PROGRESS_PADDING , 1);
            GuiSetStyle(CHECKBOX , CHECK_PADDING , 1);
            GuiSetStyle(COMBOBOX , COMBO_BUTTON_WIDTH , 32);
            GuiSetStyle(COMBOBOX , COMBO_BUTTON_SPACING , 2);
            GuiSetStyle(DROPDOWNBOX , ARROW_PADDING , 16);
            GuiSetStyle(DROPDOWNBOX , DROPDOWN_ITEMS_SPACING , 2);
            GuiSetStyle(TEXTBOX , TEXT_LINES_SPACING , (uint)((float)GuiGetStyle(DEFAULT , TEXT_SIZE) * 1.5f));
            GuiSetStyle(TEXTBOX , TEXT_INNER_PADDING , 4);
            GuiSetStyle(SPINNER , SPIN_BUTTON_WIDTH , 24);
            GuiSetStyle(SPINNER , SPIN_BUTTON_SPACING , 2);
            GuiSetStyle(SCROLLBAR , BORDER_WIDTH , 0);
            GuiSetStyle(SCROLLBAR , ARROWS_VISIBLE , 0);
            GuiSetStyle(SCROLLBAR , ARROWS_SIZE , 6);
            GuiSetStyle(SCROLLBAR , SCROLL_SLIDER_PADDING , 0);
            GuiSetStyle(SCROLLBAR , SCROLL_SLIDER_SIZE , 16);
            GuiSetStyle(SCROLLBAR , SCROLL_PADDING , 0);
            GuiSetStyle(SCROLLBAR , SCROLL_SPEED , 12);
            GuiSetStyle(LISTVIEW , LIST_ITEMS_HEIGHT , 28);
            GuiSetStyle(LISTVIEW , LIST_ITEMS_SPACING , 2);
            GuiSetStyle(LISTVIEW , SCROLLBAR_WIDTH , 12);
            GuiSetStyle(LISTVIEW , SCROLLBAR_SIDE , SCROLLBAR_RIGHT_SIDE);
            GuiSetStyle(COLORPICKER , COLOR_SELECTOR_SIZE , 8);
            GuiSetStyle(COLORPICKER , HUEBAR_WIDTH , 16);
            GuiSetStyle(COLORPICKER , HUEBAR_PADDING , 8);
            GuiSetStyle(COLORPICKER , HUEBAR_SELECTOR_HEIGHT , 8);
            GuiSetStyle(COLORPICKER , HUEBAR_SELECTOR_OVERFLOW , 2);

            if (guiFont.texture.id != Raylib.GetFontDefault().texture.id)
            {
                // Unload previous font texture
                Raylib.UnloadTexture(guiFont.texture);

                // Setup default raylib font
                guiFont = Raylib.GetFontDefault();

                // NOTE: Default raylib font character 95 is a white square
                Rectangle whiteChar;
                unsafe
                {
                    whiteChar = guiFont.recs [ 95 ];
                }
                // NOTE: We set up a 1px padding on char rectangle to avoid pixel bleeding on MSAA filtering
                Raylib.SetShapesTexture(guiFont.texture , new Rectangle(whiteChar.x + 1 , whiteChar.y + 1 , whiteChar.width - 2 , whiteChar.height - 2));
            }
        }

        public static uint GuiGetStyle(int control , int property)
        {
            if (!guiStyleLoaded) GuiLoadStyleDefault();
            return guiStyle [ control * (RAYGUI_MAX_PROPS_BASE + RAYGUI_MAX_PROPS_EXTENDED) + property ];
        }
    }
}
